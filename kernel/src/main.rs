// The no_std attribute allows us to Rust code on the bare metal without an underlying operating
// system. This means we cannot use threads, files, heap memory, the network, random numbers,
// standard output, or any other features requiring OS abstractions or specific hardware.
#![no_std]
// In a typical Rust binary that links the standard library, execution starts in a C runtime library
// that creates a stack and places the arguments in the right registers. Post this, the runtime
// calls the main function.
//
// Freestanding Rust executables do not have access to the Rust runtime. Hence, we need to remove
// the main function and provide a new entry point (the _start function defined below).
#![no_main]
// We cannot use the builtin Rust testing framework as it depends on the std library.
// The following attributes tell the Rust compiler we are using a custom Rust test framework that
// requires no external libraries and works in no_std environments.
#![feature(custom_test_frameworks)]
#![test_runner(kernel::test_runner)]
// The custom test framework feature generates a main function that calls the test runner. This
// cannot be done with #![no_main]. We thus need to change the name of the function generated by the
// framework.
#![reexport_test_harness_main = "run_tests"]

use core::panic::PanicInfo;
use kernel::{hlt, interrupts, println};

bootloader_api::entry_point!(kernel);

// Rust uses name mangling by default. Name mangling is the process of giving every function a
// unique name. We do not want the Rust compiler to change the name of the _start function. This is
// required to let the linker know of the entry point.
#[no_mangle]
// The compiler expects the entry point to never return as we have nothing to return to (no
// underlying OS). We denote this using the never type (!).
//
// If we tricked the compiler to return from the entry point, then we would just cause the CPU to
// execute random bytes that exist in memory immediately after the entry point, causing a crash or
// unpredictable behavior.
fn kernel(_boot_info: &'static mut bootloader_api::BootInfo) -> ! {
    // println!("kernel");
    // println!("This is a toy Rust kernel.");
    // println!("This OS was created in the year {}.", 2025);

    // interrupts::init();

    // We use Rust's conditional compilation feature here. This function is only called in unit
    // tests part of main.rs.
    #[cfg(test)]
    run_tests();

    hlt();
}

// This function is called on panic.
//
// A by product of not using the standard library, is that we have no panic handlers. The panic
// handler will never return and this is indicated by returning the never type (!).
//
// This panic handler is not called when we run tests.
#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    hlt();
}

// This panic handler is called when we run unit tests associated with main.rs.
#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    kernel::test_panic_handler(info)
}

#[test_case]
fn trivial_assertion() {
    assert_eq!(1, 1);
}
