// The no_std attribute allows us to Rust code on the bare metal without an underlying operating
// system. This means we cannot use threads, files, heap memory, the network, random numbers,
// standard output, or any other features requiring OS abstractions or specific hardware.
#![no_std]
// In a typical Rust binary that links the standard library, execution starts in a C runtime library
// that creates a stack and places the arguments in the right registers. Post this, the runtime
// calls the main function.
//
// Freestanding Rust executables do not have access to the Rust runtime. Hence, we need to remove
// the main function and provide a new entry point (the _start function defined below).
#![no_main]
// We cannot use the builtin Rust testing framework as it depends on the std library.
// The following attributes tell the Rust compiler we are using a custom Rust test framework that
// requires no external libraries and works in no_std environments.
#![feature(custom_test_frameworks)]
#![test_runner(kernel::test_runner)]
// The custom test framework feature generates a main function that calls the test runner. This
// cannot be done with #![no_main]. We thus need to change the name of the function generated by the
// framework.
#![reexport_test_harness_main = "run_tests"]

use bootloader_api::info::FrameBufferInfo;
use bootloader_x86_64_common::logger::LockedLogger;
use conquer_once::spin::OnceCell;
use core::panic::PanicInfo;
use kernel::{hlt, interrupts};

pub(crate) static LOGGER: OnceCell<LockedLogger> = OnceCell::uninit();

pub(crate) fn init_logger(buffer: &'static mut [u8], info: FrameBufferInfo) {
    let logger = LOGGER.get_or_init(move || LockedLogger::new(buffer, info, true, false));
    log::set_logger(logger).expect("Logger already set");
    log::set_max_level(log::LevelFilter::Trace);
    log::info!("Hello, Kernel Mode!");
}

bootloader_api::entry_point!(kernel);

// Rust uses name mangling by default. Name mangling is the process of giving every function a
// unique name. We do not want the Rust compiler to change the name of the _start function. This is
// required to let the linker know of the entry point.
#[no_mangle]
// The compiler expects the entry point to never return as we have nothing to return to (no
// underlying OS). We denote this using the never type (!).
//
// If we tricked the compiler to return from the entry point, then we would just cause the CPU to
// execute random bytes that exist in memory immediately after the entry point, causing a crash or
// unpredictable behavior.
fn kernel(boot_info: &'static mut bootloader_api::BootInfo) -> ! {
    // Free the doubly wrapped framebuffer from the boot info struct
    let frame_buffer_optional = &mut boot_info.framebuffer;
    let frame_buffer_option = frame_buffer_optional.as_mut();
    let frame_buffer_struct = frame_buffer_option.unwrap();

    // Extract the raw frame buffer
    let frame_buffer_info = frame_buffer_struct.info().clone();
    let raw_frame_buffer = frame_buffer_struct.buffer_mut();

    init_logger(raw_frame_buffer, frame_buffer_info);

    log::info!("This is a toy Rust kernel.");
    log::info!("This OS was created in the year {}.", 2025);

    interrupts::init();

    // We use Rust's conditional compilation feature here. This function is only called in unit
    // tests part of main.rs.
    #[cfg(test)]
    run_tests();

    hlt();
}

// This function is called on panic.
//
// A by product of not using the standard library, is that we have no panic handlers. The panic
// handler will never return and this is indicated by returning the never type (!).
//
// This panic handler is not called when we run tests.
#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    log::info!("{}", info);
    hlt();
}

// This panic handler is called when we run unit tests associated with main.rs.
#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    kernel::test_panic_handler(info)
}

#[test_case]
fn trivial_assertion() {
    assert_eq!(1, 1);
}
