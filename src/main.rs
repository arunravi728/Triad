// The no_std attribute allows us to Rust code on the bare metal without an underlying operating
// system. This means we cannot use threads, files, heap memory, the network, random numbers,
// standard output, or any other features requiring OS abstractions or specific hardware.
#![no_std]

// In a typical Rust binary that links the standard library, execution starts in a C runtime library
// that creates a stack and places the arguments in the right registers. Post this, the runtime
// calls the main function.
//
// Freestanding Rust executables do not have access to the Rust runtime. Hence, we need to remove
// the main function and provide a new entry point (the _start function defined below).
#![no_main]

// We cannot use the builtin Rust testing framework as it depends on the std library.
// The following attributes tell the Rust compiler we are using a custom Rust test framework that
// requires no external libraries and works in no_std environments.
#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]

// The custom test framework feature generates a main function that calls the test runner. This
// cannot be done with #![no_main]. We thus need to change the name of the function generated by the
// framework.
#![reexport_test_harness_main = "run_tests"]

use core::panic::PanicInfo;

mod vga;
mod print;

// This function is called on panic.
//
// A by product of not using the standard library, is that we have no panic handlers. The panic
// handler will never return and this is indicated by returning the never type (!).
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    loop {}
}

// Rust uses name mangling by default. Name mangling is the process of giving every function a
// unique name. We do not want the Rust compiler to change the name of the _start function. This is
// required to let the linker know of the entry point.
#[no_mangle]
pub extern "C" fn _start() -> ! {
    println!("Triad");
    println!("This is a toy Rust kernel.");
    println!("This OS was created in the year {}.", 2025);

    // We use Rust's conditional compilation feature here. This function is only called in tests.
    #[cfg(test)]
    run_tests();

    loop {}
}

// We use the isa-debug-exit device provide by QEMU to exit when running tests. We can quit QEMU
// by writing to the port exposed by the device. The isa-debug-exit device uses port-mapped I/O.
// Whenever a value is written to the ISA_DEBUG_EXIT_PORT, QEMU exits with status (value << 1) | 1.
const ISA_DEBUG_EXIT_PORT: u16 = 0xf4;

// Exit codes are chosen such that they don't clash with the default QEMU exit codes.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum QemuExitCode {
    Success = 0x10,
    Failed = 0x11,
}

pub fn exit_qemu(exit_code: QemuExitCode) {
    use x86_64::instructions::port::Port;
    // The operation is unsafe as writing to an I/O port can result in undefined behavior.
    unsafe {
        let mut port = Port::new(ISA_DEBUG_EXIT_PORT);
        port.write(exit_code as u32);
    }
}

#[cfg(test)]
pub fn test_runner(tests: &[&dyn Fn()]) {
    println!("Running {} tests", tests.len());
    for test in tests {
        test();
    }

    exit_qemu(QemuExitCode::Success);
}

#[test_case]
fn trivial_assertion() {
    print!("trivial assertion... ");
    assert_eq!(1, 1);
    println!("[ok]");
}
