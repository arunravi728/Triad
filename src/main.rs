// The no_std attribute allows us to Rust code on the bare metal without an underlying operating
// system. This means we cannot use threads, files, heap memory, the network, random numbers,
// standard output, or any other features requiring OS abstractions or specific hardware.
#![no_std]
// In a typical Rust binary that links the standard library, execution starts in a C runtime library
// that creates a stack and places the arguments in the right registers. Post this, the runtime
// calls the main function.
//
// Freestanding Rust executables do not have access to the Rust runtime. Hence, we need to remove
// the main function and provide a new entry point (the _start function defined below).
#![no_main]
// We cannot use the builtin Rust testing framework as it depends on the std library.
// The following attributes tell the Rust compiler we are using a custom Rust test framework that
// requires no external libraries and works in no_std environments.
#![feature(custom_test_frameworks)]
#![test_runner(triad::test_runner)]
// The custom test framework feature generates a main function that calls the test runner. This
// cannot be done with #![no_main]. We thus need to change the name of the function generated by the
// framework.
#![reexport_test_harness_main = "run_tests"]

use core::panic::PanicInfo;
use triad::{interrupts, println};

#[allow(dead_code)]
#[cfg(not(test))]
fn generate_divide_by_zero_interrupt() {
    unsafe {
        core::arch::asm!(
            "mov dx, 0",
            "div dx",
            out("ax") _,
            out("dx") _,
            options(nomem, nostack)
        );
    }
}

#[allow(dead_code)]
#[cfg(not(test))]
fn generate_invalid_opcode_interrupt() {
    unsafe {
        core::arch::asm!("ud2");
    };
}

#[allow(dead_code)]
#[cfg(not(test))]
fn generate_breakpoint() {
    unsafe {
        core::arch::asm!("int3", options(nomem, nostack));
    };
}

#[allow(dead_code)]
#[cfg(not(test))]
fn generate_page_fault() {
    unsafe {
        *(0xdeadbeef as *mut u8) = 42;
    };
}

// Rust uses name mangling by default. Name mangling is the process of giving every function a
// unique name. We do not want the Rust compiler to change the name of the _start function. This is
// required to let the linker know of the entry point.
#[no_mangle]
// The compiler expects the entry point to never return as we have nothing to return to (no
// underlying OS). We denote this using the never type (!).
//
// If we tricked the compiler to return from the entry point, then we would just cause the CPU to
// execute random bytes that exist in memory immediately after the entry point, causing a crash or
// unpredictable behavior.
pub extern "C" fn _start() -> ! {
    println!("Triad");
    println!("This is a toy Rust kernel.");
    println!("This OS was created in the year {}.", 2025);

    interrupts::init();

    // Generate a breakpoint interrupt when not running tests.
    #[cfg(not(test))]
    generate_breakpoint();

    #[cfg(not(test))]
    generate_page_fault();

    // We use Rust's conditional compilation feature here. This function is only called in unit
    // tests part of main.rs.
    #[cfg(test)]
    run_tests();

    loop {}
}

// This function is called on panic.
//
// A by product of not using the standard library, is that we have no panic handlers. The panic
// handler will never return and this is indicated by returning the never type (!).
//
// This panic handler is not called when we run tests.
#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    loop {}
}

// This panic handler is called when we run unit tests associated with main.rs.
#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    triad::test_panic_handler(info)
}

#[test_case]
fn trivial_assertion() {
    assert_eq!(1, 1);
}
